(1) return 0
	lua-5.2.0 fixed


GetUnmanagedSize
...
+			else if (t == typeof(lua_Number))
+				return 8;



(2) log
	lua-5.2.0 fixed

		static void print_version() {
		  Lua.luai_writestring(Lua.LUA_COPYRIGHT, (uint)Lua.strlen(Lua.LUA_COPYRIGHT)); //FIXME:changed, (uint)
		  Lua.luai_writeline();
+		  Lua.WriteLog(">>>>print_version");
		}
		

		static int loadline(Lua.lua_State L) {
			int status;
			Lua.lua_settop(L, 0);
			if (pushline(L, 1)==0)
				return -1;  /* no input */
			for (;;) {  /* repeat until gets a complete line */
			    uint l;
			    Lua.CharPtr line = Lua.lua_tolstring(L, 1, out l);
+			    Lua.WriteLog(line.ToString());



+		public static void WriteLog(string strLog)
		{
		  	string sFileName = "log_" + DateTime.Now.ToString("yyyy-MM-dd") + ".log";
		  	FileMode mode = File.Exists(sFileName) ? FileMode.Append : FileMode.Create;
		  	using (FileStream fs = new FileStream(sFileName, mode, FileAccess.Write))
		  	{
		  		using (StreamWriter sw = new StreamWriter(fs))
		  		{
			  		sw.WriteLine(DateTime.Now.ToString("yyyy-MM-dd HH-mm-ss") + "   ---   " + strLog);
		  		}
		  	}
		}

(3) a = "hello"..nil
	a = ""..nil
	lua-5.2.0 pending
	dotty dotty not work, not LUAI_THROW (LuaException)
	luaL_traceback throw exception (see (6))
	
(4)
#if CATCH_EXCEPTIONS
	lua-5.2.0 fixed
          catch (Exception e)
		  {
+          	  Debug.Assert(e is LuaException, "Exception isn't LuaException");
          	  Debug.WriteLine(e); //FIXME:added for debug

	
(5) retun a
	lua-5.2.0 fixed
	dotty dotty not work
	
			public void Write(int type, byte[] buffer, int offset, int count)
			{
				if (type == TYPE_STDOUT)
->
			public void Write(int type, byte[] buffer, int offset, int count)
			{
				if (type == TYPE_STDOUT || type == TYPE_STDERR)
...				

					if (str.Length > 0)
					{
--->						if (type == TYPE_STDOUT)
						{
							UnityEngine.Debug.Log(str);
						}
						else if (type == TYPE_STDERR)
						{
							UnityEngine.Debug.LogError(str);
						}
					}
#else
--->				if (type == TYPE_STDOUT)
					{
						stdout_.Write(buffer, offset, count);
					}
					else if (type == TYPE_STDERR)
					{
						stderr_.Write(buffer, offset, count);
					}					
#endif


(6) exception no traceback ("stack traceback:")
	luaL_traceback throw exception
	lua-5.2.0 fixed

solve:
	base_ci[0] -> base_ci

	becuase base_ci is from new CallInfo(), not from luaM_realloc_, so don't use base_ci[0]
>>>>>>>>>>>>>>>>>>>>>>	TODO:add detect code for 'values is null' error

------------------
error:

		public class CallInfo : ArrayElement
		{
			private CallInfo[] values = null;
			private int index = -1;

			public void set_index(int index)
			{
				this.index = index;
			}

			public void set_array(object array)
			{
				this.values = (CallInfo[])array;
				Debug.Assert(this.values != null);
			}

			public CallInfo this[int offset]
			{
values is null --->				get { return values[index+offset]; }
			}




	
(x)(7) seem not bug ??? 
	static Lua.CharPtr progname = LUA_PROGNAME; // <---------------progname is null
	lua-5.2.0 fixed(???)


(8) sharpdevelop x86 arch
	lua-5.2.0 pending


(9) no >> prompt
	lua-5.2.0 fixed

example:
Lua 5.2.0  Copyright (C) 1994-2011 Lua.org, PUC-Rio
> print("hello
stdin:1: unfinished string near '"hello'

		static Lua.CharPtr get_prompt(Lua.lua_State L, int firstline) {
			Lua.CharPtr p;
			Lua.lua_getglobal(L, (firstline!=0) ? "_PROMPT" : "_PROMPT2");
			p = Lua.lua_tostring(L, -1);
------>			if (p == null) p = ((firstline!=0) ? LUA_PROMPT : LUA_PROMPT2);
			Lua.lua_pop(L, 1);  /* remove global */
			return p;
		}
		static int incomplete(Lua.lua_State L, int status) {
			if (status == Lua.LUA_ERRSYNTAX) {
				uint lmsg;
				Lua.CharPtr msg = Lua.lua_tolstring(L, -1, out lmsg);
				if (lmsg >= marklen && Lua.strcmp(msg + lmsg - marklen, EOFMARK) == 0) {
not enter---->					Lua.lua_pop(L, 1);
					return 1;
				}
			}
			return 0;  /* else... */
		}

-----------------
solve:

(a)
 		/*
 		** add 1 to char to allow index -1 (EOZ)
 		*/
-		public static int testprop(int c, int p) { return luai_ctype_[c+1] & p; }
+		public static int testprop(int c, int p) { if (c == EOZ) {c = -1;} return luai_ctype_[c+1] & p; } //FIXME:added, if (c == EOZ) {c = -1;}
 		
(b)
 		private static int llex (LexState ls, SemInfo seminfo) {
 		  luaZ_resetbuffer(ls.buff);
 		  for (;;) {
-			switch (ls.current) {
+		  	switch (ls.current) {
 			  case '\n': case '\r': {  /* line breaks */
 				inclinenumber(ls);
 				break;
 			  }
 			  case ' ': case '\f': case '\t': case '\v': {  /* spaces */

(c)
 
-		public static int EOF = -1;
+		public static int EOF = 0xffff; //-1; //FIXME:changed 

(d)
fgets

 			try
 			{
 				while (true)
 				{
 					str[index] = (char)stream.ReadByte();
-					if (str[index] == '\n')
+					if (str[index] == '\r') 
+					{
+						str[index] = '\n';
+					} 
+					else if (str[index] == '\n')
+					{
+						str[index] = '\0';
 						break;
-					if (str[index] == '\xffff') //Ctrl+Z
+					}
+					else if (str[index] == '\xffff') //Ctrl+Z
+					{
 						return null;
+					}
 					if (index >= str.chars.Length)
 						break;
 					index++;
 				}
 			}

(e)
-		  int result = (byte)(z.p[0]); z.p.inc(); return result; //FIXME:changed
+		  int result = (int)(z.p[0]); z.p.inc(); return result; //FIXME:changed, (byte)->(int)
 		}
 
(f)
 	public partial class Lua
 	{
-		public const int EOZ = -1;			/* end of stream */
+		public const int EOZ = 0xffff; //-1;			/* end of stream */ //FIXME:changed here
 
 		public class ZIO : Zio { };
 
-		public static int zgetc(ZIO z) { if (z.n-- > 0) {int ch = (byte)(z.p[0]);z.p.inc();return ch;} else return luaZ_fill(z); }
-		
+		public static int zgetc(ZIO z) { if (z.n-- > 0) {int ch = (int)(z.p[0]);z.p.inc();return ch;} else { return luaZ_fill(z); }} //FIXME:(byte)->(int)		
 
+		
 		public class Mbuffer {
 		  public CharPtr buffer = new CharPtr();
 		  public uint n;
 		  public uint buffsize;
 		};

 