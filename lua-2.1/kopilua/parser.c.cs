//#define YYDEBUG
//#define LISTING
//#define MY_DEBUG

using System;
using System.Diagnostics;

namespace KopiLua
{
	using Word = System.UInt16; //unsigned short
	//using Byte = System.Byte;
	using Long = System.Int32;
	
	public partial class Lua
	{
		//#if defined (__cplusplus) || defined (c_plusplus)
		//#include <c_varieties.h>
		//#ifdef __EXTERN_C__
		//	EXTERN_FUNCTION ( extern int yylex, ());
		//#else
		//	extern int yylex();
		//#endif
		//	extern void yyerror(char *);
		//	extern int yyparse();
		//#endif
		
		//#include <malloc.h>
		
		//# line 2 "lua.stx"
		
		//char *rcs_luastx = "$Id: lua.stx,v 3.17 1995/01/13 22:11:12 roberto Exp $";
		
		//#include <stdio.h>
		//#include <stdlib.h>
		//#include <string.h>
		
		//#include "mem.h"
		//#include "opcode.h"
		//#include "hash.h"
		//#include "inout.h"
		//#include "tree.h"
		//#include "table.h"
		//#include "lua.h"
		
		/* to avoid warnings generated by yacc */
		//int yyparse (void);
		//#define malloc luaI_malloc
		//#define realloc luaI_realloc
		//#define free luaI_free
		
		//#ifndef LISTING
		//#define LISTING 0
		//#endif
		
		//#ifndef CODE_BLOCK
		//#define CODE_BLOCK 256
		private const int CODE_BLOCK = 256;
		//#endif
		private static int   maxcode;
		private static int   maxmain;
		private static Long   maxcurr;  /* to allow maxcurr *= 2 without overflow */
		private static BytePtr funcCode = null;
		//private static Byte **initcode;
		private static BytePtr basepc;
		private static int   maincode;
		private static int   pc;
		
		private const int MAXVAR = 32;
		private static Long[] varbuffer = new Long[MAXVAR];    /* variables in an assignment list;
						it's long to store negative Word values */
		private static int     nvarbuffer=0;	     /* number of variables at a list */
		
		private static Word[] localvar = new Word[STACKGAP];   /* store local variable names */
		private static int     nlocalvar=0;	     /* number of local variables */
		
		private const int MAXFIELDS = FIELDS_PER_FLUSH * 2;
		private static Word[] fields = new Word[MAXFIELDS];     /* fieldnames to be flushed */
		private static int     nfields=0;
		
		
		/* Internal functions */
		
		private static void code_byte (Byte c)
		{
		 	if (pc > maxcurr-2)  /* 1 byte free to code HALT of main code */
		 	{
		  		if (maxcurr >= MAX_INT)
		    		lua_error("code size overflow");
		  		maxcurr *= 2;
		  		if (maxcurr >= MAX_INT)
		    		maxcurr = MAX_INT;
		  		basepc.chars = growvector_Byte(basepc.chars, basepc.index, maxcurr);
		 	}
		 	basepc[pc++] = c;
		}
		
		private static void code_word (Word n)
		{
			CodeWord code = new CodeWord();
		 	code.w = n;
		 	code_byte(code.m.c1);
		 	code_byte(code.m.c2);
		}
		
		private static void code_float (float n)
		{
			CodeFloat code = new CodeFloat();
		 	code.f = n;
		 	code_byte(code.m.c1);
		 	code_byte(code.m.c2);
		 	code_byte(code.m.c3);
		 	code_byte(code.m.c4);
		}
		
		private static void code_code (BytePtr b)
		{
			b = new BytePtr(b);
			CodeCode code = new CodeCode();
			code.b = b.ToByteArray();
		 	code_byte(code.m.c1);
		 	code_byte(code.m.c2);
		 	code_byte(code.m.c3);
		 	code_byte(code.m.c4);
		}
		
		private static void code_word_at (BytePtr p, Word n)
		{
			p = new BytePtr(p);
			CodeWord code = new CodeWord();
		 	code.w = n;
		 	p[0] = code.m.c1; p.inc();
		 	p[0] = code.m.c2; p.inc();
		}
		
		private static void push_field (Word name)
		{
		  	if (nfields < STACKGAP - 1)
		    	fields[nfields++] = name;
		  	else
		   		lua_error ("too many fields in a constructor");
		}
		
		private static void flush_record (int n)
		{
		  	int i;
		  	if (n == 0) return;
		  	code_byte((Byte)OpCode.STORERECORD);
		  	code_byte((Byte)n);
		  	for (i=0; i<n; i++)
		    	code_word(fields[--nfields]);
		}
		
		private static void flush_list (int m, int n)
		{
		  	if (n == 0) return;
		  	if (m == 0)
		  		code_byte((Byte)OpCode.STORELIST0);
		  	else if (m < 255)
		  	{
		    	code_byte((Byte)OpCode.STORELIST);
		    	code_byte((Byte)m);
		  	}
		  	else
		   		lua_error ("list constructor too long");
		  	code_byte((Byte)n);
		}
		
		private static void add_nlocalvar (int n)
		{
		 	if (MAX_TEMPS + nlocalvar + MAXVAR + n < STACKGAP)
		  		nlocalvar += n;
		 	else
		  		lua_error ("too many local variables");
		}
		
		private static void incr_nvarbuffer ()
		{
		 	if (nvarbuffer < MAXVAR-1)
		  		nvarbuffer++;
		 	else
		  		lua_error ("variable buffer overflow");
		}
		
		private static void code_number (float f)
		{ 
		  	Word i = (Word)f;
		  	if (f == (float)i)  /* f has an (short) integer value */
		  	{
		  		if (i <= 2) code_byte((Byte)((Byte)OpCode.PUSH0 + i));
		   		else if (i <= 255)
		   		{
		    		code_byte((Byte)OpCode.PUSHBYTE);
		    		code_byte((Byte)i);
		   		}
		   		else
		   		{
		    		code_byte((Byte)OpCode.PUSHWORD);
		   			code_word(i);
		   		}
		  	}
		  	else
		  	{
		   		code_byte((Byte)OpCode.PUSHFLOAT);
		   		code_float(f);
		  	}
		}
		
		/*
		** Search a local name and if find return its index. If do not find return -1
		*/
		private static int lua_localname (Word n)
		{
		 	int i;
		 	for (i=nlocalvar-1; i >= 0; i--)
		  		if (n == localvar[i]) return i;	/* local var */
		 	return -1;		        /* global var */
		}
		
		/*
		** Push a variable given a number. If number is positive, push global variable
		** indexed by (number -1). If negative, push local indexed by ABS(number)-1.
		** Otherwise, if zero, push indexed variable (record).
		*/
		private static void lua_pushvar (Long number)
		{ 
		 	if (number > 0)	/* global var */
		 	{
		  		code_byte((Byte)OpCode.PUSHGLOBAL);
		  		code_word((Word)(number-1));
		 	}
		 	else if (number < 0)	/* local var */
		 	{
		  		number = (-number) - 1;
		  		if (number < 10) code_byte((Byte)((Byte)OpCode.PUSHLOCAL0 + number));
		  		else
		  		{
		   			code_byte((Byte)OpCode.PUSHLOCAL);
		   			code_byte((Byte)number);
		  		}
		 	}
		 	else
		 	{
		  		code_byte((Byte)OpCode.PUSHINDEXED);
		 	}
		}
		
		private static void lua_codeadjust (int n)
		{
		 	if (n+nlocalvar == 0)
		  		code_byte((Byte)OpCode.ADJUST0);
		 	else
		 	{
		   		code_byte((Byte)OpCode.ADJUST);
		   		code_byte((Byte)(n + nlocalvar));
		 	}
		}
		
		private static void init_function (TreeNode func)
		{
		 	if (funcCode == null)	/* first function */
		 	{
		 		funcCode = newvector_Byte(CODE_BLOCK);
		  		maxcode = CODE_BLOCK;
		 	}
		 	pc = 0; basepc = new BytePtr(funcCode); maxcurr = maxcode;
		 	nlocalvar = 0;
		  	if (0!=lua_debug)
		  	{
		    	code_byte((Byte)OpCode.SETFUNCTION); 
		    	code_code(new BytePtr(luaI_strdup(lua_file[lua_nfile-1])));
		    	code_word(luaI_findconstant(func));
		  	}
		}
		
		private static void codereturn ()
		{
		  	if (0!=lua_debug) code_byte((Byte)OpCode.RESET); 
		  	if (nlocalvar == 0)
		    	code_byte((Byte)OpCode.RETCODE0);
		  	else
		  	{
		    	code_byte((Byte)OpCode.RETCODE);
		    	code_byte((Byte)nlocalvar);
		  	}
		}
		
		private static void codedebugline ()
		{
		  	if (0!=lua_debug)
		  	{
		    	code_byte((Byte)OpCode.SETLINE);
		    	code_word(lua_linenumber);
		  	}
		}
		
		private static void adjust_mult_assign (int vars, int exps, int temps)
		{
		  	if (exps < 0) 
		  	{
		    	int r = vars - (-exps-1);
		    	if (r >= 0)
		      		code_byte((Byte)r);
		    	else
		    	{
		      		code_byte(0);
		      		lua_codeadjust(temps);
		    	}
		  	}
		  	else if (vars != exps)
		  		lua_codeadjust(temps);
		}
		
		private static void lua_codestore (int i)
		{
		 	if (varbuffer[i] > 0)		/* global var */
		 	{
		  		code_byte((Byte)OpCode.STOREGLOBAL);
		  		code_word((Word)(varbuffer[i]-1));
		 	}
		 	else if (varbuffer[i] < 0)      /* local var */
		 	{
		  		int number = (-varbuffer[i]) - 1;
		  		if (number < 10) code_byte((Byte)((Byte)OpCode.STORELOCAL0 + number));
		  		else
		  		{
		   			code_byte((Byte)OpCode.STORELOCAL);
		   			code_byte((Byte)number);
		  		}
		 	}
		 	else				  /* indexed var */
		 	{
		  		int j;
		  		int upper = 0;     	/* number of indexed variables upper */
		  		int param;		/* number of itens until indexed expression */
		  		for (j = i + 1; j < nvarbuffer; j++)
		   			if (varbuffer[j] == 0) upper++;
		  		param = upper * 2 + i;
		  		if (param == 0)
		   			code_byte((Byte)OpCode.STOREINDEXED0);
		  		else
		  		{
		   			code_byte((Byte)OpCode.STOREINDEXED);
		   			code_byte((Byte)param);
		  		}
		 	}
		}
		
		private static void codeIf (Long thenAdd, Long elseAdd)
		{
		  	Long elseinit = elseAdd + sizeof_Word() + 1;
		  	if (pc == elseinit)		/* no else */
		  	{
		    	pc -= sizeof_Word() + 1;
		    	elseinit = pc;
		  	}
		  	else
		  	{
		  		basepc[elseAdd] = (Byte)OpCode.JMP;
		  		code_word_at(basepc + elseAdd + 1, (Word)(pc - elseinit));
		  	}
		  	basepc[thenAdd] = (Byte)OpCode.IFFJMP;
		  	code_word_at(basepc + thenAdd + 1, (Word)(elseinit - (thenAdd + sizeof_Word() + 1)));
		}
		
		private static CharPtr yyerror_msg = new CharPtr(new char[256]);
		private static void yyerror (CharPtr s)
		{
		 	sprintf (yyerror_msg,"%s near \"%s\" at line %d in file \"%s\"",
		    		s, lua_lasttext (), lua_linenumber, lua_filename());
		 	lua_error (yyerror_msg);
		}
		
		
		/*
		** Parse LUA code.
		*/
		public static void lua_parse (ref BytePtr initcode) /*Byte **code ==> initcode*/
		{
		 	//initcode = code;
		 	initcode = newvector_Byte(CODE_BLOCK);
		 	maincode = 0; 
		 	maxmain = CODE_BLOCK;
		 	if (0!=yyparse (ref initcode)) lua_error("parse error");
		 	initcode[maincode++] = (Byte)OpCode.RETCODE0;
#if LISTING
			{ 
				//static void PrintCode (Byte *c, Byte *end);
				PrintCode(initcode, initcode+maincode);
			}
#endif
		}
		
		
		
		//# line 365 "lua.stx"
//		typedef union  
//		{
//		 int   vInt;
//		 float vFloat;
//		 char *pChar;
//		 Word  vWord;
//		 Long  vLong;
//		 Byte *pByte;
//		 TreeNode *pNode;
//		} YYSTYPE;
//		# define WRONGTOKEN 257
//		# define NIL 258
//		# define IF 259
//		# define THEN 260
//		# define ELSE 261
//		# define ELSEIF 262
//		# define WHILE 263
//		# define DO 264
//		# define REPEAT 265
//		# define UNTIL 266
//		# define END 267
//		# define RETURN 268
//		# define LOCAL 269
//		# define FUNCTION 270
//		# define NUMBER 271
//		# define STRING 272
//		# define NAME 273
//		# define DEBUG 274
//		# define AND 275
//		# define OR 276
//		# define EQ 277
//		# define NE 278
//		# define LE 279
//		# define GE 280
//		# define CONC 281
//		# define UNARY 282
//		# define NOT 283
		//#define yyclearin yychar = -1
		//#define yyerrok yyerrflag = 0
		//extern int yychar;
		//extern int yyerrflag;
		//#ifndef YYMAXDEPTH
		//#define YYMAXDEPTH 150
		private const int YYMAXDEPTH = 150;
		//#endif
		private static YYSTYPE yylval = new YYSTYPE(), yyval = new YYSTYPE();
		private const int YYERRCODE = 256;
		
		//# line 737 "lua.stx"
		
		
#if LISTING
		private static void PrintCode (BytePtr code, BytePtr end)
		{
			code = new BytePtr(code);
			end = new BytePtr(end);
			BytePtr p = new BytePtr(code);
			
		 	printf ("\n\nCODE\n");
		 	while (p != end)
		 	{
		 		switch ((OpCode)p[0])
		  		{
	   			case OpCode.PUSHNIL:	
	  				printf ("%d    PUSHNIL\n", p - code); 
	  				p.inc();
	  				break;
	  				
	   			case OpCode.PUSH0: case OpCode.PUSH1: case OpCode.PUSH2:
	  				printf ("%d    PUSH%c\n", p - code, (char)(p[0] - OpCode.PUSH0 + '0'));
	  				p.inc();
	   				break;
	   				
	   			case OpCode.PUSHBYTE:
	   				p.inc();
	   				printf ("%d    PUSHBYTE   %d\n", p - code, p[0]);
	   				p.inc();
	   				break;
	   				
	   			case OpCode.PUSHWORD:
	                {
	   					CodeWord c = new CodeWord();
				 		int n = p - code;
				 		p.inc();
				 		get_word(c, p);
	    			 	printf ("%d    PUSHWORD   %d\n", n, c.w);
					}
	   				break;
	   				
	   			case OpCode.PUSHFLOAT:
					{
	   					CodeFloat c = new CodeFloat();
				 		int n = p - code;
				 		p.inc();
				 		get_float(c, p);
	    			 	printf ("%d    PUSHFLOAT  %f\n", n, c.f);
					}
	   				break;
	   				
	   			case OpCode.PUSHSTRING:
	    			{
	   					CodeWord c = new CodeWord();
				 		int n = p - code;
				 		p.inc();
				 		get_word(c, p);
	    				printf ("%d    PUSHSTRING   %d\n", n, c.w);
					}
	   				break;
	   				
	   			case OpCode.PUSHFUNCTION:
					{
	   					CodeCode c = new CodeCode();
				 		int n = p - code;
				 		p.inc();
				 		get_code(c, p);
				 		printf ("%d    PUSHFUNCTION  %p\n", n, c.b);
					}
					break;
	
	   			case OpCode.PUSHLOCAL0: case OpCode.PUSHLOCAL1: case OpCode.PUSHLOCAL2: case OpCode.PUSHLOCAL3:
	   			case OpCode.PUSHLOCAL4: case OpCode.PUSHLOCAL5: case OpCode.PUSHLOCAL6: case OpCode.PUSHLOCAL7:
	   			case OpCode.PUSHLOCAL8: case OpCode.PUSHLOCAL9:
					printf ("%d    PUSHLOCAL%c\n", p - code, (char)(p[0] - OpCode.PUSHLOCAL0 + '0'));
					p.inc();
	   				break;
	   				
	   			case OpCode.PUSHLOCAL:	
	   				p.inc();
	   				printf ("%d    PUSHLOCAL   %d\n", p - code, p[0]);
	   				p.inc();
	   				break;
	   				
	   			case OpCode.PUSHGLOBAL:
	    			{
	   					CodeWord c = new CodeWord();
				 		int n = p - code;
				 		p.inc();
				 		get_word(c, p);
	    			 	printf ("%d    PUSHGLOBAL   %d\n", n, c.w);
					}
	   				break;
	   				
	   			case OpCode.PUSHINDEXED:    
	   				printf ("%d    PUSHINDEXED\n", p - code);
	   				p.inc();
	   				break;
	   			
	   			case OpCode.STORELOCAL0: case OpCode.STORELOCAL1: case OpCode.STORELOCAL2: case OpCode.STORELOCAL3:
	   			case OpCode.STORELOCAL4: case OpCode.STORELOCAL5: case OpCode.STORELOCAL6: case OpCode.STORELOCAL7:
	   			case OpCode.STORELOCAL8: case OpCode.STORELOCAL9:
	   				printf ("%d    STORELOCAL%c\n", p - code, (char)(p[0] - OpCode.STORELOCAL0 + '0'));
	    			p.inc();
	   				break;
	   				
	   			case OpCode.STORELOCAL:
	   				p.inc();
	   				printf ("%d    STORELOCAL   %d\n", p - code, p[0]);
	    			p.inc();
	   				break;
	   				
	   			case OpCode.STOREGLOBAL:
	    			{
	   					CodeWord c = new CodeWord();
				 		int n = p-code;
				 		p.inc();
				 		get_word(c, p);
	    			 	printf ("%d    STOREGLOBAL   %d\n", n, c.w);
					}
	   				break;
	   				
	   			case OpCode.PUSHSELF:
	    			{
	   					CodeWord c = new CodeWord();
				 		int n = p - code;
				 		p.inc();
				 		get_word(c,p);
	    			 	printf ("%d    PUSHSELF   %d\n", n, c.w);
					}
					break;
					
	   			case OpCode.STOREINDEXED0:  
					printf ("%d    STOREINDEXED0\n", p - code); 
					p.inc();
					break;
					
	   			case OpCode.STOREINDEXED:   
					p.inc();
					printf ("%d    STOREINDEXED   %d\n", p - code, p[0]);
					p.inc();
	   				break;
	   				
	   			case OpCode.STORELIST0:
	   				p.inc();
	   				printf("%d      STORELIST0  %d\n", p - code, p[0]);
					p.inc();
	        		break;
	        		
	   			case OpCode.STORELIST:
	        		printf("%d      STORELIST  %d %d\n", p-code, p[1], p[2]);
	        		p += 3;
	        		break;
	        		
	   			case OpCode.STORERECORD:
	        		p.inc();
	        		printf("%d      STORERECORD  %d\n", p-code, p[0]);
	        		p += p[0] * sizeof_Word() + 1;
	       			break;
	       			
	   			case OpCode.ADJUST0: 
	       			printf ("%d    ADJUST0\n", p - code); 
	       			p.inc();
	       			break;
	       			
	   			case OpCode.ADJUST:
	       			p.inc();
	       			printf ("%d    ADJUST   %d\n", p - code, p[0]);
	    			p.inc();
	   				break;
	   				
	   			case OpCode.CREATEARRAY:	
	    			{
	   					CodeWord c = new CodeWord();
						int n = p - code;
						p.inc();
						get_word(c, p);
						printf ("%d    CREATEARRAY %d\n", n, c.w);
						break;
					}
	   				
				case OpCode.EQOP:       	
	   				printf ("%d    EQOP\n", p - code);
	   				p.inc();
	   				break;
	   				
				case OpCode.LTOP:       	
	   				printf ("%d    LTOP\n", p - code);
	   				p.inc();
	   				break;
	   				
				case OpCode.LEOP:       	
	   				printf ("%d    LEOP\n", p - code);
	   				p.inc();
	   				break;
	   				
				case OpCode.ADDOP:       	
	   				printf ("%d    ADDOP\n", p - code);
	   				p.inc();
	   				break;
	   				
				case OpCode.SUBOP:       	
	   				printf ("%d    SUBOP\n", p - code);
	   				p.inc();
	   				break;
	   				
				case OpCode.MULTOP:      	
	   				printf ("%d    MULTOP\n", p - code);
	   				p.inc();
	   				break;
	   				
				case OpCode.DIVOP:       	
	   				printf ("%d    DIVOP\n", p - code);
	   				p.inc();
	   				break;
	   				
				case OpCode.POWOP:       	
	   				printf ("%d    POWOP\n", p - code);
	   				p.inc();
	   				break;
	   				
				case OpCode.CONCOP:       	
	   				printf ("%d    CONCOP\n", p - code);
	   				p.inc();
	   				break;
	   				
				case OpCode.MINUSOP:       
	   				printf ("%d    MINUSOP\n", p - code);
	   				p.inc();
	   				break;
	   				
				case OpCode.NOTOP:       	
	   				printf ("%d    NOTOP\n", p - code);
	   				p.inc();
	   				break;
	   				
	   			case OpCode.ONTJMP:	   
	    			{
						CodeWord c = new CodeWord();
				 		int n = p-code;
				 		p.inc();
				 		get_word(c,p);
	    			 	printf ("%d    ONTJMP  %d\n", n, c.w);
					}
	   				break;
	   				
	   			case OpCode.ONFJMP:	   
	    			{
	   					CodeWord c = new CodeWord();
				 		int n = p - code;
				 		p.inc();
				 		get_word(c, p);
	    			 	printf ("%d    ONFJMP  %d\n", n, c.w);
					}
	   				break;
	   				
	   			case OpCode.JMP:	   
	    			{
	   					CodeWord c = new CodeWord();
				 		int n = p - code;
				 		p.inc();
				 		get_word(c, p);
	    			 	printf ("%d    JMP  %d\n", n, c.w);
					}
	   				break;
	   				
	   			case OpCode.UPJMP:
	    			{
	   					CodeWord c = new CodeWord();
				 		int n = p - code;
				 		p.inc();
				 		get_word(c, p);
	    			 	printf ("%d    UPJMP  %d\n", n, c.w);
					}
	   				break;
	   				
	   			case OpCode.IFFJMP:
	    			{
	   					CodeWord c = new CodeWord();
				 		int n = p - code;
				 		p.inc();
				 		get_word(c, p);
	    			 	printf ("%d    IFFJMP  %d\n", n, c.w);
					}
	   				break;
	   				
	   			case OpCode.IFFUPJMP:
	    			{
	   					CodeWord c = new CodeWord();
				 		int n = p - code;
				 		p.inc();
				 		get_word(c, p);
	    			 	printf ("%d    IFFUPJMP  %d\n", n, c.w);
					}
	   				break;
	   				
	   			case OpCode.POP:       	
	   				printf ("%d    POP\n", p - code);
	   				p.inc();
	   				break;
	   
	   			case OpCode.CALLFUNC:
	   				printf ("%d    CALLFUNC %d %d\n", p-code, p[1], p[2]);
					p+=3;
					break;
	   
				case OpCode.RETCODE0: 
					printf ("%d    RETCODE0\n", p - code);
					p.inc();
					break;
	   
				case OpCode.RETCODE:
					p.inc();
					printf ("%d    RETCODE   %d\n", p - code, p[0]);
	    			p.inc();
	   				break;
	   				
	   			case OpCode.SETFUNCTION:
	            	{
	   					CodeCode c1 = new CodeCode();
	   					CodeWord c2 = new CodeWord();
	                    int n = p - code;
	                    p.inc();
	                    get_code(c1, p);
	                    get_word(c2, p);
	                    printf ("%d    SETFUNCTION  %s  %d\n", n, new CharPtr(c1.b), c2.w);
	                }
	                break;
	                
	   			case OpCode.SETLINE:
	            	{
	                	CodeWord c = new CodeWord();
	                    int n = p - code;
	                    p.inc();
	                    get_word(c, p);
	                    printf ("%d    SETLINE  %d\n", n, c.w);
	                }
	                break;
	
	   			case OpCode.RESET:		
	            	printf ("%d    RESET\n", p - code);
	            	p.inc();
	            	break;
	            	
	   			default:		
	            	printf ("%d    Cannot happen: code %d\n", p - code, p[-1]);//FIXME:????
	            	p.inc();
	            	break;
		  		}
		 	}
		}
#endif
		
		public static int[] yyexca = {
		-1, 1,
			0, -1,
			-2, 2,
		-1, 20,
			61, 91,
			44, 91,
			-2, 97,
		-1, 32,
			40, 66,
			123, 66,
			-2, 53,
		-1, 47,
			123, 63,
			-2, 70,
		-1, 74,
			125, 79,
			-2, 63,
		-1, 79,
			275, 37,
			276, 37,
			277, 37,
			278, 37,
			62, 37,
			60, 37,
			279, 37,
			280, 37,
			281, 37,
			43, 37,
			45, 37,
			42, 37,
			47, 37,
			94, 37,
			-2, 72,
		-1, 80,
			91, 97,
			46, 97,
			-2, 92,
		-1, 118,
			261, 33,
			262, 33,
			266, 33,
			267, 33,
			-2, 16,
		-1, 133,
			125, 85,
			-2, 63,
		-1, 158,
			123, 63,
			-2, 70,
		-1, 159,
			275, 37,
			276, 37,
			277, 37,
			278, 37,
			62, 37,
			60, 37,
			279, 37,
			280, 37,
			281, 37,
			43, 37,
			45, 37,
			42, 37,
			47, 37,
			94, 37,
			-2, 74,
		};
		private const int YYNPROD = 103;
		private const int YYLAST = 351;
		private static int[] yyact = {
		    64,    62,     6,    63,   152,    65,     7,    64,    62,   145,
		    63,   120,    65,    92,    64,    62,    89,    63,    57,    65,
		    58,    64,    62,    87,    63,    57,    65,    58,    64,    62,
		    24,    63,    57,    65,    58,    64,    62,    54,    63,    57,
		    65,    58,    45,    10,    29,   142,    57,   171,    58,    30,
		    29,   123,    66,   167,    14,    30,   160,   117,    15,    66,
		    16,   162,   163,   173,    19,   131,    66,   138,    24,    28,
		   112,   114,   130,    66,    74,    71,     8,    64,    66,    52,
		    66,    86,    65,    51,   161,    83,    51,    66,    43,   136,
		    27,    12,    64,    62,    26,    63,   133,    65,    49,    70,
		   135,   119,    84,   125,   124,    42,    72,   122,   109,    32,
		    53,   132,    79,    73,    85,    39,    75,    79,    47,    23,
		   149,    91,   143,    31,    78,    20,    88,    38,    50,    66,
		    11,    50,    95,    96,    97,    98,    99,   100,   101,   102,
		   103,   104,   105,   106,    66,    48,    36,   129,   128,   158,
		   113,   141,    94,    81,    79,    77,    18,    41,    40,    80,
		   139,    13,     9,   118,    90,    93,   121,    25,     5,     4,
		     3,     2,    22,   126,   111,    76,    82,    44,   134,   110,
		    21,    46,    17,     1,     0,     0,     0,     0,     0,     0,
		     0,     0,     0,     0,     0,   140,     0,     0,     0,     0,
		     0,     0,     0,     0,   147,   148,     0,   151,     0,   150,
		     0,     0,   153,   159,     0,   156,     0,     0,     0,     0,
		   164,   107,   108,     0,     0,     0,     0,     0,    79,   116,
		   170,   169,    55,    68,    69,    56,    59,    60,    61,    67,
		    68,    69,    56,    59,    60,    61,    67,    68,    69,    56,
		    59,    60,    61,    67,    68,    69,    56,    59,    60,    61,
		    67,   177,    35,    56,    59,    60,    61,    67,    35,   137,
		   127,   157,     0,   166,    67,    33,    34,    24,     0,     0,
		   146,    33,    34,   115,     0,     0,     0,    37,     0,     0,
		     0,   155,     0,    37,     0,     0,     0,   172,     0,     0,
		   144,     0,     0,     0,     0,     0,     0,   165,     0,     0,
		     0,     0,     0,   154,     0,     0,     0,     0,     0,     0,
		     0,     0,     0,     0,     0,     0,   174,     0,   176,     0,
		     0,     0,     0,     0,     0,     0,     0,     0,   168,     0,
		     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
		   175 
		};
		private static int[] yypact = {
		 -1000,  -268, -1000, -1000, -1000, -1000,  -230, -1000,    32,  -205,
		    36, -1000, -1000, -1000,     4, -1000, -1000,    44, -1000,  -231,
		 -1000,    78, -1000,    40, -1000,    70,  -236,   -28, -1000,     4,
		     4, -1000,    40, -1000, -1000, -1000, -1000,     4,   -49, -1000,
		     4, -1000,     4,  -243,    41, -1000, -1000,     4, -1000,  -250,
		     4,  -257, -1000,  -260, -1000, -1000,     4,     4,     4,     4,
		     4,     4,     4,     4,     4,     4,     4,     4, -1000, -1000,
		    67,   -21,   -16,   -16,    10,   -35,  -209, -1000,    57, -1000,
		 -1000,    37, -1000,  -262,     4,    66,    57, -1000,   -42, -1000,
		    63,    59, -1000,    70, -1000,    -7,    -7,    -7,    -7,    -7,
		    -7,    35,    35,   -16,   -16,   -16,    50, -1000, -1000, -1000,
		   -53,    52,    56,   -21, -1000,    28, -1000, -1000,  -223, -1000,
		 -1000,    57, -1000, -1000, -1000,  -264, -1000, -1000,     4,     4,
		 -1000, -1000, -1000,     4, -1000,  -269,     4, -1000, -1000,     4,
		    32, -1000, -1000,     4,  -211, -1000,  -200,   -14,   -14,  -269,
		   -21, -1000,    28,   -21, -1000, -1000,   -21, -1000,     4, -1000,
		 -1000,  -214, -1000, -1000,    56,  -220,    32, -1000, -1000,  -197,
		 -1000, -1000, -1000, -1000, -1000, -1000,  -200, -1000 
		};
		private static int[] yypgo = {
		     0,   183,   152,    69,   114,    81,   182,   181,   180,   179,
		   177,   176,    70,   174,   115,   172,    79,   171,    76,   130,
		   170,   169,   168,   167,   165,   164,   175,   163,   162,   161,
		    67,   160,    75,    84,   158,   157,   146,   155,   151,   149,
		   123,   109,   148,   147,   127,   122,   121,    65,   120,    71 
		};
		private static int[] yyr1 = {
		     0,     1,    17,     1,     1,     1,     1,    23,    20,    24,
		    21,    16,    27,    27,    19,    19,    28,    18,    31,    30,
		    29,    34,    29,    35,    29,    29,    29,    29,    33,    33,
		    33,    37,    26,    38,    39,    38,     2,    32,     3,     3,
		     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
		     3,     3,     3,     3,     3,     3,     3,     3,     3,    42,
		     3,    43,     3,    44,    40,    36,     8,     8,     7,     7,
		     4,     4,     5,    45,     5,    25,    25,    46,    46,     9,
		     9,     9,    48,     9,    47,    47,    12,    12,    49,    13,
		    13,     6,     6,    14,    14,    14,    15,    41,    10,    10,
		    11,    11,    22 
		};
		private static int[] yyr2 = {
		     0,     0,     1,     9,     4,     4,     4,     1,     9,     1,
		    13,    11,     0,     6,     0,     2,     1,     4,     1,     4,
		    17,     1,    17,     1,    13,     7,     3,     7,     0,     4,
		    15,     1,     7,     0,     1,     9,     1,     3,     7,     7,
		     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,
		     7,     5,     3,     3,     3,     3,     3,     3,     5,     1,
		    11,     1,    11,     1,     9,     5,     3,     7,     7,     3,
		     1,     3,     3,     1,     9,     1,     3,     3,     7,     1,
		     5,     5,     1,    11,     0,     2,     3,     7,     7,     3,
		     7,     3,     7,     3,     9,     7,     3,     3,     3,     7,
		     1,     5,     3 
		};
		private static int[] yychk = {
		 -1000,    -1,   -17,   -20,   -21,   -22,   270,   274,   -18,   -28,
		   273,   -19,    59,   -29,   259,   263,   265,    -6,   -36,   269,
		   -14,    -8,   -15,   -41,   273,   -23,    58,   -32,    -3,    40,
		    45,   -40,   -41,   271,   272,   258,   -36,   283,   -44,   -14,
		   -34,   -35,    61,    44,   -10,   273,    -7,    40,   -40,    58,
		    91,    46,   -16,    40,   273,   260,   277,    60,    62,   278,
		   279,   280,    43,    45,    42,    47,    94,   281,   275,   276,
		    -3,   -32,   -32,   -32,   123,   -32,   -26,   -37,    -5,    -3,
		   -14,   -41,   -11,    44,    61,    -4,    -5,   273,   -32,   273,
		   -25,   -46,   273,   -24,    -2,   -32,   -32,   -32,   -32,   -32,
		   -32,   -32,   -32,   -32,   -32,   -32,   -32,    -2,    -2,    41,
		    -9,   -13,   -12,   -32,   -49,   273,   264,   266,   -27,    44,
		   273,    -5,    41,    93,    41,    44,   -16,   -26,   -42,   -43,
		   125,   -47,    59,    44,   -47,    44,    61,    -2,   -30,   -31,
		   -18,   -38,   268,   -45,   -26,   273,    -2,   -32,   -32,   -48,
		   -32,   -49,   273,   -32,   -26,    -2,   -32,   -19,   -39,    -3,
		   267,   -33,   261,   262,   -12,    -2,    -4,   267,   -26,   -30,
		   -47,   267,   -19,   260,    -2,   -26,    -2,   -33 
		};
		private static int[] yydef = {
		     1,    -2,    16,     4,     5,     6,     0,   102,    14,     0,
		     7,     3,    15,    17,    63,    21,    23,     0,    26,     0,
		    -2,    63,    93,    66,    96,     0,     0,     0,    37,    63,
		    63,    52,    -2,    54,    55,    56,    57,    63,     0,    97,
		    63,    31,    63,     0,   100,    98,    65,    -2,    69,     0,
		    63,     0,     8,    75,     9,    36,    63,    63,    63,    63,
		    63,    63,    63,    63,    63,    63,    63,    63,    36,    36,
		    37,     0,    51,    58,    -2,     0,     0,    12,    25,    -2,
		    -2,     0,    27,     0,    63,     0,    71,    67,     0,    95,
		     0,    76,    77,     0,    31,    39,    40,    41,    42,    43,
		    44,    45,    46,    47,    48,    49,    50,    59,    61,    38,
		     0,    84,    84,    89,    86,    96,    36,    18,    -2,    73,
		    99,   101,    68,    94,    31,     0,    10,    36,    63,    63,
		    64,    80,    82,    -2,    81,    85,    63,    31,    36,    63,
		    14,    32,    34,    63,     0,    78,    28,    60,    62,     0,
		    90,    87,     0,    88,    36,    24,    19,    13,    -2,    -2,
		    11,     0,    31,    18,    84,     0,    14,    20,    29,     0,
		    83,    22,    35,    36,    31,    36,    28,    30 
		};
		//typedef struct { char *t_name; int t_val; } yytoktype;
		public class yytoktype {public CharPtr t_name; public int t_val; 
			public yytoktype(CharPtr t_name, int t_val) 
			{ 
				this.t_name = t_name; 
				this.t_val = t_val;
			} 
		}
		//#ifndef YYDEBUG
		//#	define YYDEBUG	0	/* don't allow debugging */
		//#endif
		
#if YYDEBUG
		
		public static yytoktype[] yytoks =
		{
			new yytoktype("WRONGTOKEN", 257),
			new yytoktype("NIL", 258),
			new yytoktype("IF", 259),
			new yytoktype("THEN", 260),
			new yytoktype("ELSE", 261),
			new yytoktype("ELSEIF", 262),
			new yytoktype("WHILE", 263),
			new yytoktype("DO", 264),
			new yytoktype("REPEAT", 265),
			new yytoktype("UNTIL", 266),
			new yytoktype("END", 267),
			new yytoktype("RETURN", 268),
			new yytoktype("LOCAL", 269),
			new yytoktype("FUNCTION", 270),
			new yytoktype("NUMBER", 271),
			new yytoktype("STRING", 272),
			new yytoktype("NAME", 273),
			new yytoktype("DEBUG", 274),
			new yytoktype("AND", 275),
			new yytoktype("OR", 276),
			new yytoktype("EQ", 277),
			new yytoktype("NE", 278),
			new yytoktype(">", 62),
			new yytoktype("<", 60),
			new yytoktype("LE", 279),
			new yytoktype("GE", 280),
			new yytoktype("CONC", 281),
			new yytoktype("+", 43),
			new yytoktype("-", 45),
			new yytoktype("*", 42),
			new yytoktype("/", 47),
			new yytoktype("UNARY", 282),
			new yytoktype("NOT", 283),
			new yytoktype("^", 94),
			new yytoktype("-unknown-", -1),	/* ends search */
		};
		
		public static string[] yyreds =
		{
			"-no such reduction-",
			"functionlist : /* empty */",
			"functionlist : functionlist",
			"functionlist : functionlist stat sc",
			"functionlist : functionlist function",
			"functionlist : functionlist method",
			"functionlist : functionlist setdebug",
			"function : FUNCTION NAME",
			"function : FUNCTION NAME body",
			"method : FUNCTION NAME ':' NAME",
			"method : FUNCTION NAME ':' NAME body",
			"body : '(' parlist ')' block END",
			"statlist : /* empty */",
			"statlist : statlist stat sc",
			"sc : /* empty */",
			"sc : ';'",
			"stat : /* empty */",
			"stat : stat1",
			"cond : /* empty */",
			"cond : expr1",
			"stat1 : IF expr1 THEN PrepJump block PrepJump elsepart END",
			"stat1 : WHILE",
			"stat1 : WHILE expr1 DO PrepJump block PrepJump END",
			"stat1 : REPEAT",
			"stat1 : REPEAT block UNTIL cond PrepJump",
			"stat1 : varlist1 '=' exprlist1",
			"stat1 : functioncall",
			"stat1 : LOCAL localdeclist decinit",
			"elsepart : /* empty */",
			"elsepart : ELSE block",
			"elsepart : ELSEIF cond THEN PrepJump block PrepJump elsepart",
			"block : /* empty */",
			"block : statlist ret",
			"ret : /* empty */",
			"ret : RETURN",
			"ret : RETURN exprlist sc",
			"PrepJump : /* empty */",
			"expr1 : expr",
			"expr : '(' expr ')'",
			"expr : expr1 EQ expr1",
			"expr : expr1 '<' expr1",
			"expr : expr1 '>' expr1",
			"expr : expr1 NE expr1",
			"expr : expr1 LE expr1",
			"expr : expr1 GE expr1",
			"expr : expr1 '+' expr1",
			"expr : expr1 '-' expr1",
			"expr : expr1 '*' expr1",
			"expr : expr1 '/' expr1",
			"expr : expr1 '^' expr1",
			"expr : expr1 CONC expr1",
			"expr : '-' expr1",
			"expr : table",
			"expr : varexp",
			"expr : NUMBER",
			"expr : STRING",
			"expr : NIL",
			"expr : functioncall",
			"expr : NOT expr1",
			"expr : expr1 AND PrepJump",
			"expr : expr1 AND PrepJump expr1",
			"expr : expr1 OR PrepJump",
			"expr : expr1 OR PrepJump expr1",
			"table : /* empty */",
			"table : '{' fieldlist '}'",
			"functioncall : funcvalue funcParams",
			"funcvalue : varexp",
			"funcvalue : varexp ':' NAME",
			"funcParams : '(' exprlist ')'",
			"funcParams : table",
			"exprlist : /* empty */",
			"exprlist : exprlist1",
			"exprlist1 : expr",
			"exprlist1 : exprlist1 ','",
			"exprlist1 : exprlist1 ',' expr",
			"parlist : /* empty */",
			"parlist : parlist1",
			"parlist1 : NAME",
			"parlist1 : parlist1 ',' NAME",
			"fieldlist : /* empty */",
			"fieldlist : lfieldlist1 lastcomma",
			"fieldlist : ffieldlist1 lastcomma",
			"fieldlist : lfieldlist1 ';'",
			"fieldlist : lfieldlist1 ';' ffieldlist1 lastcomma",
			"lastcomma : /* empty */",
			"lastcomma : ','",
			"ffieldlist1 : ffield",
			"ffieldlist1 : ffieldlist1 ',' ffield",
			"ffield : NAME '=' expr1",
			"lfieldlist1 : expr1",
			"lfieldlist1 : lfieldlist1 ',' expr1",
			"varlist1 : var",
			"varlist1 : varlist1 ',' var",
			"var : singlevar",
			"var : varexp '[' expr1 ']'",
			"var : varexp '.' NAME",
			"singlevar : NAME",
			"varexp : var",
			"localdeclist : NAME",
			"localdeclist : localdeclist ',' NAME",
			"decinit : /* empty */",
			"decinit : '=' exprlist1",
			"setdebug : DEBUG",
		};
#endif 
		/* YYDEBUG */
		//#line 1 "/usr/lang/SC1.0/yaccpar"
		/*	@(#)yaccpar 1.10 89/04/04 SMI; from S5R3 1.10	*/
		
		/*
		** Skeleton parser driver for yacc output
		*/
		/*
			@(#)RELEASE SC1.0 C++ 2.1 1Mar1991
		*/
		
		/*
		** yacc user known macros and defines
		*/
//		#define YYERROR		goto yyerrlab
		public static int YYACCEPT() { return(0); }
		public static int YYABORT() { return(1); }
//		#define YYBACKUP( newtoken, newvalue )\
//		{\
//			if ( yychar >= 0 || ( yyr2[ yytmp ] >> 1 ) != 1 )\
//			{\
//				yyerror( "syntax error - cannot backup" );\
//				goto yyerrlab;\
//			}\
//			yychar = newtoken;\
//			yystate = *yyps;\
//			yylval = newvalue;\
//			goto yynewstate;\
//		}
//		#define YYRECOVERING()	(!!yyerrflag)
//		#define YYCOPY(to, from, type) \
//			(type *) memcpy(to, (char *) from, yynewmax * sizeof(type))
//		#ifndef YYDEBUG
//		#	define YYDEBUG	1	/* make debugging available */
//		#endif
		
		
		/*
		** extern declarations for C++ - check your own code for correctness
		** if you have function redefined error messages here.
		*/
		
//		#ifdef __cplusplus
//		EXTERN_FUNCTION ( extern int printf,    (const char*, DOTDOTDOT) );
//		EXTERN_FUNCTION ( extern void *memcpy,  (void *, const void *, int) );
//		#endif
		
		
		/*
		** user known globals
		*/
#if YYDEBUG
		private static int yydebug = 1; // set to 1 to get debugging 
#else
		///private static int yydebug = 0; // set to 1 to get debugging
#endif
		
		/*
		** driver internal defines
		*/
		private const int YYFLAG = (-1000);
		
		/*
		** static variables used by the parser
		*/
		private static YYSTYPE[] yy_yyv = yy_yyv_init(), yyv = yy_yyv;	/* value stack */
		private static YYSTYPE[] yy_yyv_init()
		{
			YYSTYPE[] result = new YYSTYPE[YYMAXDEPTH];
			for (int i = 0; i < result.Length; ++i)
			{
				result[i] = new YYSTYPE();
			}
			return result;
		}
		private static int[] yy_yys = new int[YYMAXDEPTH], yys = yy_yys;	/* state stack */
		
		private static YYSTYPEPtr yypv;			/* top of value stack */
		private static IntegerPtr yyps;			/* top of state stack */
		
		private static int yystate;			/* current state */
		private static int yytmp;			/* extra var (lasts between blocks) */
		
//		#if defined(__cplusplus) || defined(__STDC__) || defined(lint)
//		static int __yaccpar_lint_hack__ = 0;   
//						/* if you change the value from 0 to
//						something else, make sure you know
//						what to do with yyerrlab reference.
//						This is a hack - to make sure C++ and
//						lint are happy with the 4.1 yacc code. */
//		#endif
		
		public static int yynerrs;			/* number of errors */
		
		public static int yyerrflag;			/* error recovery flag */
		public static int yychar;			/* current input token number */
		private static uint yymaxdepth = YYMAXDEPTH;
		
		
		/*
		** yyparse - return 0 if worked, 1 if syntax error not recovered from
		*/
		public static int yyparse(ref BytePtr initcode)
		{
		    YYSTYPEPtr yypvt = null;        /* top of value stack for
												$vars */
		
			/*
			** Initialize externals - yyparse may be called more than once
			*/
			yypv = new YYSTYPEPtr(yyv, -1);
			yyps = new IntegerPtr(yys, -1);
			yystate = 0;
			yytmp = 0;
			yynerrs = 0;
			yyerrflag = 0;
			yychar = -1;
		
//		#if defined(__cplusplus) || defined(__STDC__) || defined(lint)
//		/*
//		   Note that the following can never be executed but simply to please
//		   lint and C++
//		 */
//			switch (__yaccpar_lint_hack__)
//			{
//				case 1: goto yyerrlab;
//				case 2: goto yynewstate;
//			}
//		#endif
		
//			{ //FIXME:start: see below, goto yystack;
			YYSTYPEPtr yy_pv;	/* top of value stack */
			IntegerPtr yy_ps;		/* top of state stack */
			int yy_state;		/* current state */
			int  yy_n;		/* internal state number info */
	
			//goto yystack; //FIXME:move to below
	
			/*
			** get globals into registers.
			** branch to here only if YYBACKUP was called.
			*/
//yynewstate:
//			yy_pv = yypv;
//			yy_ps = yyps;
//			yy_state = yystate;
//			goto yy_newstate;
		
			/*
			** get globals into registers.
			** either we just started, or we just finished a reduction
			*/
yystack:
			yy_pv = new YYSTYPEPtr(yypv);
			yy_ps = new IntegerPtr(yyps);
			yy_state = yystate;
		
			/*
			** top of for (;;) loop while no reductions done
			*/
yy_stack:
			/*
			** put a state and value onto the stacks
			*/
#if YYDEBUG
			/*
			** if debugging, look up token value in list of value vs.
			** name pairs.  0 and negative (-1) are special values.
			** Note: linear search is used since time is not a real
			** consideration while debugging.
			*/
			if (yydebug != 0)
			{
				int yy_i;
	
				printf( "State %d, token ", yy_state );
				if ( yychar == 0 )
					printf( "end-of-file\n" );
				else if ( yychar < 0 )
					printf( "-none-\n" );
				else
				{
					for ( yy_i = 0; yytoks[yy_i].t_val >= 0;
						yy_i++ )
					{
						if ( yytoks[yy_i].t_val == yychar )
							break;
					}
					printf( "%s\n", yytoks[yy_i].t_name );
				}
			}
#endif
			yy_ps.inc();
			if ( yy_ps >= new IntegerPtr(yys, (int)yymaxdepth) )	/* room on stack? */
			{
                /*
                ** reallocate and recover.  Note that pointers
                ** have to be reset, or bad things will happen
                */ 
				int yyps_index = (yy_ps - yys);
				int yypv_index = (yy_pv - yyv);
				int yypvt_index = (yypvt - yyv);
                int yynewmax;
	
                yynewmax = (int)(yymaxdepth + YYMAXDEPTH);
				if (yymaxdepth == YYMAXDEPTH)	/* first time growth */
				{
					YYSTYPE[] newyyv = malloc_YYSTYPE(yynewmax);
					int[] newyys = malloc_int(yynewmax);
					if (newyys != null && newyyv != (YYSTYPEPtr)null)
					{
						yys = memcpy_IntegerPtr(newyys, yys, yynewmax);
						yyv = memcpy_YYSTYPE(newyyv, yyv, yynewmax);
					}
					else
						yynewmax = 0;	/* failed */
				}
				else				/* not first time */
				{
					yyv = realloc_YYSTYPE(yyv,
					                      (uint)yynewmax);
					yys = realloc_int(yys,
					                  (uint)yynewmax);
					if (yys == null || yyv == null)
						yynewmax = 0;	/* failed */
				}
				if (yynewmax <= yymaxdepth)	/* tables not expanded */
				{
					yyerror( "yacc stack overflow" );
					return YYABORT();
				}
				yymaxdepth = (uint)yynewmax;
		
				yy_ps = new IntegerPtr(yys, yyps_index);
				yy_pv = new YYSTYPEPtr(yyv, yypv_index);
				yypvt = new YYSTYPEPtr(yyv, yypvt_index);
			}
			yy_ps[0] = yy_state;
			yy_pv.inc(); yy_pv[0].set(yyval);
		
			/*
			** we have a new state - find out what to do
			*/
yy_newstate:
			//if ( ( yy_n = yypact[ yy_state ] ) <= YYFLAG ) {
			yy_n = yypact[ yy_state ];
#if MY_DEBUG
			printf(">>> yy_state, yy_n == %d, %d\n", yy_state, yy_n);
#endif
			if (yy_n <= YYFLAG) {
				goto yydefault;		/* simple state */
			}
#if YYDEBUG
			/*
			** if debugging, need to mark whether new token grabbed
			*/
			yytmp = yychar < 0 ? 1 : 0;
#endif
			if ((yychar < 0) && ((yychar = yylex()) < 0))
			{
				yychar = 0; // reached EOF
			}
#if YYDEBUG
			if ( yydebug!=0 && yytmp!=0 )
			{
				int yy_i;

				printf( "Received token " );
				if ( yychar == 0 )
					printf( "end-of-file\n" );
				else if ( yychar < 0 )
					printf( "-none-\n" );
				else
				{
					for ( yy_i = 0;
						yytoks[yy_i].t_val >= 0;
						yy_i++ )
					{
						if ( yytoks[yy_i].t_val
							== yychar )
						{
							break;
						}
					}
					printf( "%s\n", yytoks[yy_i].t_name );
				}
			}
#endif
#if MY_DEBUG
			printf("<<< yy_n, yychar == %d, %d\n", yy_n, yychar);
#endif
			if ( ( ( yy_n += yychar ) < 0 ) || ( yy_n >= YYLAST ) ) {
				goto yydefault;
			}
			if ( yychk[ yy_n = yyact[ yy_n ] ] == yychar )	/*valid shift*/
			{
				yychar = -1;
				yyval = yylval;
				yy_state = yy_n;
				if ( yyerrflag > 0 )
					yyerrflag--;
				goto yy_stack;
			}
	
yydefault:
			if ( ( yy_n = yydef[ yy_state ] ) == -2 )
			{
#if YYDEBUG
				yytmp = (yychar < 0 ? 1 : 0);
#endif
				if ( ( yychar < 0 ) && ( ( yychar = yylex() ) < 0 ) )
					yychar = 0;		/* reached EOF */
#if YYDEBUG
				if ( yydebug != 0 && yytmp != 0 )
				{
					int yy_i;
	
					printf( "Received token " );
					if ( yychar == 0 )
						printf( "end-of-file\n" );
					else if ( yychar < 0 )
						printf( "-none-\n" );
					else
					{
						for ( yy_i = 0;
							yytoks[yy_i].t_val >= 0;
							yy_i++ )
						{
							if ( yytoks[yy_i].t_val
								== yychar )
							{
								break;
							}
						}
						printf( "%s\n", yytoks[yy_i].t_name );
					}
				}
#endif
				/*
				** look through exception table
				*/
				{
					IntegerPtr yyxi = new IntegerPtr(yyexca);
	
					while ( ( yyxi[0] != -1 ) ||
						( yyxi[1] != yy_state ) )
					{
						yyxi += 2;
					}
					while ( ( (yyxi += 2)[0] >= 0 ) &&
					    ( yyxi[0] != yychar ) )
						;
					if ( ( yy_n = yyxi[1] ) < 0 )
						return YYACCEPT();
				}
			}


				
			/*
			** check for syntax error
			*/
			if (yy_n == 0) // have an error
			{
				/* no worry about speed here! */
				switch (yyerrflag)
				{
				case 0: // new error
					yyerror("syntax error");
					goto case 1; //goto skip_init;
//yyerrlab:
//					/*
//					** get globals into registers.
//					** we have a user generated syntax type error
//					*/
//					yy_pv = yypv;
//					yy_ps = yyps;
//					yy_state = yystate;
//					yynerrs++;
//					goto case 1;
//skip_init:
				case 1:
				case 2: 	/* incompletely recovered error */
						/* try again... */
					yyerrflag = 3;
					/*
					** find state where "error" is a legal
					** shift action
					*/
					while (yy_ps >= yys)
					{
						yy_n = yypact[yy_ps[0]] + YYERRCODE;
						if (yy_n >= 0 && yy_n < YYLAST && yychk[yyact[yy_n]] == YYERRCODE)
						{
							/*
							** simulate shift of "error"
							*/
							yy_state = yyact[yy_n];
							goto yy_stack;
						}
						/*
						** current state has no shift on
						** "error", pop stack
						*/
#if YYDEBUG
						string _POP_ = "Error recovery pops state %d, uncovers state %d\n";
						if (yydebug != 0)
						{
							printf(_POP_, yy_ps, yy_ps[-1]);
						}
						//# undef _POP_
#endif
						yy_ps.dec();
						yy_pv.dec();
					}
					/*
					** there is no state on stack with "error" as
					** a valid shift.  give up.
					*/
					return YYABORT();
					
				case 3: // no shift yet; eat a token
#if YYDEBUG
					/*
					** if debugging, look up token in list of
					** pairs.  0 and negative shouldn't occur,
					** but since timing doesn't matter when
					** debugging, it doesn't hurt to leave the
					** tests here.
					*/
					if ( yydebug != 0 )
					{
						int yy_i;
	
						printf( "Error recovery discards " );
						if ( yychar == 0 )
							printf( "token end-of-file\n" );
						else if ( yychar < 0 )
							printf( "token -none-\n" );
						else
						{
							for ( yy_i = 0;
								yytoks[yy_i].t_val >= 0;
								yy_i++ )
							{
								if ( yytoks[yy_i].t_val
									== yychar )
								{
									break;
								}
							}
							printf( "token %s\n",
								yytoks[yy_i].t_name );
						}
					}
#endif
					if (yychar == 0) // reached EOF. quit
					{
						return YYABORT();
					}
					yychar = -1;
					goto yy_newstate;
				}
			} // end if ( yy_n == 0 )
			
			/*
			** reduction by production yy_n
			** put stack tops, etc. so things right after switch
			*/
#if YYDEBUG
			/*
			** if debugging, print the string that is the user's
			** specification of the reduction which is just about
			** to be done.
			*/
			if ( yydebug != 0 )
				printf( "Reduce by (%d) \"%s\"\n",
					yy_n, yyreds[ yy_n ] );
#endif
			yytmp = yy_n;			/* value to switch over */
			yypvt = yy_pv;			/* $vars top of value stack */
			/*
			** Look in goto table for next state
			** Sorry about using yy_state here as temporary
			** register variable, but why not, if it works...
			** If yyr2[ yy_n ] doesn't have the low order bit
			** set, then there is no action to be done for
			** this reduction.  So, no saving & unsaving of
			** registers done.  The only difference between the
			** code just after the if and the body of the if is
			** the goto yy_stack in the body.  This way the test
			** can be made before the choice of what to do is needed.
			*/
			{
				/* length of production doubled with extra bit */
				int yy_len = yyr2[ yy_n ];
	
				if ( ( yy_len & 01 )==0 )
				{
					yy_len >>= 1;
					yyval = ( yy_pv -= yy_len )[1];	/* $$ = $1 */
					yy_state = yypgo[ yy_n = yyr1[ yy_n ] ] +
						( yy_ps -= yy_len )[0] + 1;
					if ( yy_state >= YYLAST ||
						yychk[ yy_state =
						yyact[ yy_state ] ] != -yy_n )
					{
						yy_state = yyact[ yypgo[ yy_n ] ];
					}
					goto yy_stack;
				}
				yy_len >>= 1;
				yyval = ( yy_pv -= yy_len )[1];	/* $$ = $1 */
				yy_state = yypgo[ yy_n = yyr1[ yy_n ] ] +
					( yy_ps -= yy_len )[0] + 1;
				if ( yy_state >= YYLAST ||
					yychk[ yy_state = yyact[ yy_state ] ] != -yy_n )
				{
					yy_state = yyact[ yypgo[ yy_n ] ];
				}
			}
					/* save until reenter driver code */
			yystate = yy_state;
			yyps = new IntegerPtr(yy_ps);
			yypv = new YYSTYPEPtr(yy_pv);
				


//			} //FIXME:end: goto yystack;				
			/*
			** code supplied by user is placed in this switch
			*/
			switch( yytmp )
			{
			case 2:
				//# line 411 "lua.stx"
				{
			  		pc = maincode; 
			  		basepc = new BytePtr(initcode);
			  		maxcurr = maxmain;
				  	nlocalvar = 0;
			    } 
				break;
		
			case 3:
				//# line 416 "lua.stx"
				{
					maincode = pc; 
					initcode = new BytePtr(basepc);
					maxmain = maxcurr;
				} 
				break;
		
			case 7:
				//# line 425 "lua.stx"
				{
					init_function(yypvt[-0].pNode);
			    } 
				break;
				
			case 8:
				//# line 429 "lua.stx"
				{ 
					Word func = luaI_findsymbol(yypvt[-2].pNode);
					s_tag(func, lua_Type.LUA_T_FUNCTION);
					s_bvalue(func, yypvt[-0].pByte);
				} 
				break;
		
			case 9:
				//# line 437 "lua.stx"
				{
					init_function(yypvt[-0].pNode);
			        localvar[nlocalvar] = luaI_findsymbolbyname("self");
			        add_nlocalvar(1);
			    } 
				break;
		
			case 10:
				//# line 443 "lua.stx"
				{
			        /* assign function to table field */
			        pc = maincode; 
			        basepc = new BytePtr(initcode);
			        maxcurr = maxmain;
			        nlocalvar = 0;
					lua_pushvar(luaI_findsymbol(yypvt[-4].pNode) + 1);
		            code_byte((Byte)OpCode.PUSHSTRING);
					code_word(luaI_findconstant(yypvt[-2].pNode));
		            code_byte((Byte)OpCode.PUSHFUNCTION);
		            code_code(yypvt[-0].pByte);
		            code_byte((Byte)OpCode.STOREINDEXED0);
					maincode = pc; 
					initcode = new BytePtr(basepc);
					maxmain = maxcurr;
			    } 
				break;
		
			case 11:
				//# line 458 "lua.stx"
				{
		    		codereturn();
		    		yyval.pByte = newvector_Byte(pc);
		    		memcpy(yyval.pByte, basepc, (uint)pc);
		    		funcCode = new BytePtr(basepc); maxcode=maxcurr;
#if LISTING
					PrintCode(funcCode,funcCode+pc);
#endif
				} 
				break;
		
			case 16:
				//# line 475 "lua.stx"
				{ 
					codedebugline(); 
				} 
				break;
		
			case 18:
				//# line 477 "lua.stx"
				{ 
					codedebugline(); 
				} 
				break;
		
			case 20:
				//# line 480 "lua.stx"
				{ 
					codeIf((Long)yypvt[-4].vLong, (Long)yypvt[-2].vLong);
				} 
				break;
		
			case 21:
				//# line 482 "lua.stx"
				{
					yyval.vLong = pc;
				} 
				break;
		
			case 22:
				//# line 483 "lua.stx"
				{
		       		basepc[yypvt[-3].vLong] = (Byte)OpCode.IFFJMP;
		       		code_word_at(new BytePtr(basepc, (int)(yypvt[-3].vLong + 1)), (Word)(pc - (yypvt[-3].vLong + sizeof_Word() + 1)));
		        	basepc[yypvt[-1].vLong] = (Byte)OpCode.UPJMP;
		        	code_word_at(new BytePtr(basepc, (int)(yypvt[-1].vLong + 1)), (Word)(pc - (yypvt[-6].vLong)));
		       	} 
				break;
		
			case 23:
				//# line 490 "lua.stx"
				{
					yyval.vLong = pc;
				} 
				break;
		
			case 24:
				//# line 491 "lua.stx"
				{
		        	basepc[yypvt[-0].vLong] = (Byte)OpCode.IFFUPJMP;
		        	code_word_at(new BytePtr(basepc, (int)(yypvt[-0].vLong + 1)), (Word)(pc - (yypvt[-4].vLong)));
		       	} 
				break;
		
			case 25:
				//# line 497 "lua.stx"
				{
		        	{
		         		int i;
		         		adjust_mult_assign(nvarbuffer, yypvt[-0].vInt, yypvt[-2].vInt * 2 + nvarbuffer);
			 			for (i = nvarbuffer - 1; i >= 0; i--)
			  				lua_codestore (i);
			 			if (yypvt[-2].vInt > 1 || (yypvt[-2].vInt == 1 && varbuffer[0] != 0))
			  				lua_codeadjust (0);
					}
		       	} 
				break;
		
			case 26:
				//# line 507 "lua.stx"
				{ 
					code_byte(0); 
				} 
				break;
		
			case 27:
				//# line 509 "lua.stx"
				{ 
					add_nlocalvar(yypvt[-1].vInt);
			  		adjust_mult_assign(yypvt[-1].vInt, yypvt[-0].vInt, 0);
			 	} 
				break;
		
			case 30:
				//# line 517 "lua.stx"
				{ 
					codeIf((Long)yypvt[-3].vLong, (Long)yypvt[-1].vLong);
				} 
				break;
		
			case 31:
				//# line 520 "lua.stx"
				{
					yyval.vInt = nlocalvar;
				} 
				break;
		
			case 32:
				//# line 521 "lua.stx"
				{
			  		if (nlocalvar != yypvt[-2].vInt)
			  		{
		           		nlocalvar = yypvt[-2].vInt;
			   			lua_codeadjust (0);
			  		}
		        } 
				break;
		
			case 34:
				//# line 531 "lua.stx"
				{ 
					codedebugline(); 
				} 
				break;
		
			case 35:
				//# line 532 "lua.stx"
				{
		        	if (yypvt[-1].vInt < 0) 
		        		code_byte(MULT_RET);
		           	codereturn();
		        } 
				break;
		
			case 36:
				//# line 539 "lua.stx"
				{ 
			  		yyval.vLong = pc;
			  		code_byte(0);		/* open space */
			  		code_word (0);
		        } 
				break;
		
			case 37:
				//# line 545 "lua.stx"
				{ 
					if (yypvt[-0].vInt == 0) 
						code_byte(1); 
				} 
				break;
		
			case 38:
				//# line 548 "lua.stx"
				{ 
					yyval.vInt = yypvt[-1].vInt; 
				} 
				break;
		
			case 39:
				//# line 549 "lua.stx"
				{ 
					code_byte((Byte)OpCode.EQOP);
					yyval.vInt = 1; 
				} 
				break;
		
			case 40:
				//# line 550 "lua.stx"
				{ 
					code_byte((Byte)OpCode.LTOP);   
					yyval.vInt = 1; 
				} 
				break;
		
			case 41:
				//# line 551 "lua.stx"
				{ 
					code_byte((Byte)OpCode.GTOP);   
					yyval.vInt = 1; 
				} 
				break;
		
			case 42:
				//# line 552 "lua.stx"
				{ 
					code_byte((Byte)OpCode.EQOP); 
					code_byte((Byte)OpCode.NOTOP); 
					yyval.vInt = 1; 
				} 
				break;
		
			case 43:
				//# line 553 "lua.stx"
				{ 
					code_byte((Byte)OpCode.LEOP);   
					yyval.vInt = 1; 
				} 
				break;
		
			case 44:
				//# line 554 "lua.stx"
				{ 
					code_byte((Byte)OpCode.GEOP);   
					yyval.vInt = 1; 
				} 
				break;
		
			case 45:
				//# line 555 "lua.stx"
				{ 
					code_byte((Byte)OpCode.ADDOP);  
					yyval.vInt = 1; 
				} 
				break;
		
			case 46:
				//# line 556 "lua.stx"
				{ 
					code_byte((Byte)OpCode.SUBOP);  
					yyval.vInt = 1; 
				} 
				break;
		
			case 47:
				//# line 557 "lua.stx"
				{ 
					code_byte((Byte)OpCode.MULTOP); 
					yyval.vInt = 1; 
				} 
				break;
		
			case 48:
				//# line 558 "lua.stx"
				{ 
					code_byte((Byte)OpCode.DIVOP);  
					yyval.vInt = 1; 
				} 
				break;
		
			case 49:
				//# line 559 "lua.stx"
				{ 
					code_byte((Byte)OpCode.POWOP);  
					yyval.vInt = 1; 
				} 
				break;
		
			case 50:
				//# line 560 "lua.stx"
				{ 
					code_byte((Byte)OpCode.CONCOP);  
					yyval.vInt = 1; 
				} 
				break;
		
			case 51:
				//# line 561 "lua.stx"
				{ 
					code_byte((Byte)OpCode.MINUSOP); 
					yyval.vInt = 1;
				} 
				break;
		
			case 52:
				//# line 562 "lua.stx"
				{ 
					yyval.vInt = 1; 
				} 
				break;
		
			case 53:
				//# line 563 "lua.stx"
				{ 
					yyval.vInt = 1;
				} 
				break;
		
			case 54:
				//# line 564 "lua.stx"
				{ 
					code_number(yypvt[-0].vFloat); 
					yyval.vInt = 1; 
				} 
				break;
		
			case 55:
				//# line 566 "lua.stx"
				{
		      		code_byte((Byte)OpCode.PUSHSTRING);
		      		code_word(yypvt[-0].vWord);
		      		yyval.vInt = 1;
		     	} 
				break;
		
			case 56:
				//# line 571 "lua.stx"
				{
					code_byte((Byte)OpCode.PUSHNIL); 
					yyval.vInt = 1; 
				} 
				break;
		
			case 57:
				//# line 572 "lua.stx"
				{ 
					yyval.vInt = 0; 
				} 
				break;
		
			case 58:
				//# line 573 "lua.stx"
				{ 
					code_byte((Byte)OpCode.NOTOP);  
					yyval.vInt = 1;
				} 
				break;
				
			case 59:
				//# line 574 "lua.stx"
				{
					code_byte((Byte)OpCode.POP); 
				} 
				break;
		
			case 60:
				//# line 575 "lua.stx"
				{ 
		    		basepc[yypvt[-2].vLong] = (Byte)OpCode.ONFJMP;
		    		code_word_at(new BytePtr(basepc, (int)(yypvt[-2].vLong + 1)), (Word)(pc - (yypvt[-2].vLong + sizeof_Word()+1)));
		      		yyval.vInt = 1;
		     	} 
				break;
		
			case 61:
				//# line 580 "lua.stx"
				{
					code_byte((Byte)OpCode.POP); 
				} 
				break;
		
			case 62:
				//# line 581 "lua.stx"
				{ 
			    	basepc[yypvt[-2].vLong] = (Byte)OpCode.ONTJMP;
			    	code_word_at(new BytePtr(basepc, (int)(yypvt[-2].vLong + 1)), (Word)(pc - (yypvt[-2].vLong + sizeof_Word() + 1)));
			      	yyval.vInt = 1;
			    } 
				break;
		
			case 63:
				//# line 589 "lua.stx"
				{
		      		code_byte((Byte)OpCode.CREATEARRAY);
		      		yyval.vLong = pc; 
		      		code_word(0);
		     	} 
				break;
		
			case 64:
				//# line 594 "lua.stx"
				{
					code_word_at(new BytePtr(basepc, (int)(yypvt[-3].vLong)), (Word)yypvt[-1].vInt);
		     	} 
				break;
		
			case 65:
				//# line 600 "lua.stx"
				{ 
					code_byte((Byte)OpCode.CALLFUNC); 
					code_byte((Byte)(yypvt[-1].vInt + yypvt[-0].vInt));
				} 
				break;
		
			case 66:
				//# line 603 "lua.stx"
				{ 
					yyval.vInt = 0; 
				} 
				break;
				
			case 67:
				//# line 605 "lua.stx"
				{ 
		        	code_byte((Byte)OpCode.PUSHSELF); 
			       	code_word(luaI_findconstant(yypvt[-0].pNode));
		            yyval.vInt = 1;
			    } 
				break;
		
			case 68:
				//# line 613 "lua.stx"
				{ 
					if (yypvt[-1].vInt<0) 
					{ 
						code_byte(1); 
						yyval.vInt = -yypvt[-1].vInt; 
					} 
					else 
						yyval.vInt = yypvt[-1].vInt; 
				} 
				break;
		
			case 69:
				//# line 614 "lua.stx"
				{ 
					yyval.vInt = 1; 
				} 
				break;
		
			case 70:
				//# line 617 "lua.stx"
				{
					yyval.vInt = 0; 
				} 
				break;
		
			case 71:
				//# line 618 "lua.stx"
				{ 
					yyval.vInt = yypvt[-0].vInt; 
				} 
				break;
		
			case 72:
				//# line 621 "lua.stx"
				{ 
					if (yypvt[-0].vInt == 0) 
						yyval.vInt = -1; 
					else 
						yyval.vInt = 1; 
				} 
				break;
		
			case 73:
				//# line 622 "lua.stx"
				{ 
					if (yypvt[-1].vInt < 0) 
						code_byte(1); 
				} 
				break;
		
			case 74:
				//# line 623 "lua.stx"
				{
		        	int r = yypvt[-3].vInt < 0 ? -yypvt[-3].vInt : yypvt[-3].vInt;
		          	yyval.vInt = (yypvt[-0].vInt == 0) ? -(r+1) : r+1;
				} 
				break;
				
			case 75:
				//# line 629 "lua.stx"
				{ 
					lua_codeadjust(0); 
				} 
				break;
		
			case 76:
				//# line 630 "lua.stx"
				{ 
					lua_codeadjust(0); 
				} 
				break;
		
			case 77:
				//# line 634 "lua.stx"
				{
					localvar[nlocalvar]=luaI_findsymbol(yypvt[-0].pNode); 
				 	add_nlocalvar(1);
				} 
				break;
		
			case 78:
				//# line 639 "lua.stx"
				{
					localvar[nlocalvar]=luaI_findsymbol(yypvt[-0].pNode); 
				 	add_nlocalvar(1);
				} 
				break;
		
			case 79:
				//# line 645 "lua.stx"
				{ 
					yyval.vInt =  0; 
				} 
				break;
		
			case 80:
				//# line 647 "lua.stx"
				{ 
					yyval.vInt = yypvt[-1].vInt; 
					flush_list(yypvt[-1].vInt/FIELDS_PER_FLUSH, yypvt[-1].vInt%FIELDS_PER_FLUSH); 
				} 
				break;
		
			case 81:
				//# line 649 "lua.stx"
				{ 
					yyval.vInt = yypvt[-1].vInt; 
					flush_record(yypvt[-1].vInt%FIELDS_PER_FLUSH); 
				} 
				break;
		
			case 82:
				//# line 651 "lua.stx"
				{ 
					flush_list(yypvt[-1].vInt/FIELDS_PER_FLUSH, yypvt[-1].vInt%FIELDS_PER_FLUSH); 
				} 
				break;
		
			case 83:
				//# line 653 "lua.stx"
				{ 
					yyval.vInt = yypvt[-4].vInt + yypvt[-1].vInt; 
					flush_record(yypvt[-1].vInt % FIELDS_PER_FLUSH); 
				} 
				break;
		
			case 86:
				//# line 660 "lua.stx"
				{
					yyval.vInt=1;
				} 
				break;
		
			case 87:
				//# line 662 "lua.stx"
				{
					yyval.vInt = yypvt[-2].vInt + 1;
				  	if (yyval.vInt % FIELDS_PER_FLUSH == 0) 
				  		flush_record(FIELDS_PER_FLUSH);
				} 
				break;
		
			case 88:
				//# line 669 "lua.stx"
				{ 
			    	push_field(luaI_findconstant(yypvt[-2].pNode));
				} 
				break;
		
			case 89:
				//# line 674 "lua.stx"
				{
					yyval.vInt=1;
				} 
				break;
		
			case 90:
				//# line 676 "lua.stx"
				{
					yyval.vInt = yypvt[-2].vInt + 1;
				  	if (yyval.vInt % FIELDS_PER_FLUSH == 0) 
				    	flush_list(yyval.vInt / FIELDS_PER_FLUSH - 1, FIELDS_PER_FLUSH);
				} 
				break;
		
			case 91:
				//# line 684 "lua.stx"
				{
			   		nvarbuffer = 0; 
			   		varbuffer[nvarbuffer] = (Long)yypvt[-0].vLong; incr_nvarbuffer();
			   		yyval.vInt = (yypvt[-0].vLong == 0) ? 1 : 0;
			  	} 
				break;
		
			case 92:
				//# line 690 "lua.stx"
				{ 
					varbuffer[nvarbuffer] = (Long)yypvt[-0].vLong; incr_nvarbuffer();
			   		yyval.vInt = (yypvt[-0].vLong == 0) ? yypvt[-2].vInt + 1 : yypvt[-2].vInt;
			  	} 
				break;
		
			case 93:
				//# line 696 "lua.stx"
				{ 
					yyval.vLong = yypvt[-0].vLong; 
				} 
				break;
		
			case 94:
				//# line 698 "lua.stx"
				{
			   		yyval.vLong = 0;		/* indexed variable */
			  	} 
				break;
			
			case 95:
				//# line 702 "lua.stx"
				{
			   		code_byte((Byte)OpCode.PUSHSTRING);
			   		code_word(luaI_findconstant(yypvt[-0].pNode));
			   		yyval.vLong = 0;		/* indexed variable */
			  	} 
				break;
				
			case 96:
				//# line 710 "lua.stx"
				{
			   		Word s = luaI_findsymbol(yypvt[-0].pNode);
			   		int local = lua_localname (s);
			   		if (local == -1)	/* global var */
			    		yyval.vLong = s + 1;		/* return positive value */
		        	else
			    		yyval.vLong = -(local+1);		/* return negative value */
			  	} 
				break;
		
			case 97:
				//# line 720 "lua.stx"
				{ 
					lua_pushvar((Long)yypvt[-0].vLong);
				} 
				break;
		
			case 98:
				//# line 723 "lua.stx"
				{
					localvar[nlocalvar] = luaI_findsymbol(yypvt[-0].pNode); 
					yyval.vInt = 1;
				} 
				break;
		
			case 99:
				//# line 725 "lua.stx"
				{
			    	localvar[nlocalvar + yypvt[-2].vInt] = luaI_findsymbol(yypvt[-0].pNode); 
			     	yyval.vInt = yypvt[-2].vInt + 1;
			    } 
				break;
		
			case 100:
				//# line 731 "lua.stx"
				{ 
					yyval.vInt = 0; 
				} 
				break;
			
			case 101:
				//# line 732 "lua.stx"
				{ 
					yyval.vInt = yypvt[-0].vInt; 
				}
				break;
		
			case 102:
				//# line 735 "lua.stx"
				{
					lua_debug = yypvt[-0].vInt;
				} 
				break;
			}
			goto yystack;		/* reset registers in driver code */
		}
	}
}
